# JS闭包私房菜



- JavaScript 中的作用域是什么意思?

- 闭包会在哪些场景中使用？

- 通过定时器循环输出自增的数字通过 JS 的代码如何实现？

## 作用域

作用域通俗来讲，就是指变量能够被访问到的范围。

ES5 之前只有全局作用域和函数作用域两种，ES6 出现之后，又新增了块级作用域。

### 全局作用域

一般来说，变量分为全局变量和局部变量两种。 js中，全局变量是挂载在 window 下的变量，所以在任何位置和场景，你都能访问到该变量。

> 那什么是全局作用域?

有一个简单的说法... 不在任何函数内定义的*变量*就具有*全局作用域*

### 函数作用域

在 js 中，函数中定义的变量叫作函数变量，这个时候只能在函数内部才能访问到它，所以它的作用域也就是函数的内部，称为函数作用域

### 块级作用域

ES6 中新增了块级作用域，最直接的表现就是新增的 let 关键词，let 定义的变量只能在块级作用域中被访问，有“暂时性死区”的特点，也就是说这个变量在定义之前是不能被使用的。

最简单的鉴别方式: {}内的都是块级作用域



## 闭包



### 官方定义

- 红宝书闭包的定义：闭包是指有权访问另外一个函数作用域中的变量的函数。
- MDN：一个函数和对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）

吐槽：mdn这个说法太绕了....



### 大白话解释闭包

通俗地讲：闭包其实就是一个函数，一个什么函数？一个可以访问其他函数**内部变量**的函数

PS：通常情况下，函数内部变量是无法在外部访问

🌰例子：



```js
const fun1 = () => {
  let a = 1;
  return function() {
    console.log(a);
  };
};
fun1();
let result = fun1();
result(); // 1

```



通过闭包，最后还是可以拿到 a 变量的值



## 闭包产生的原因

前面，说了作用域，接下来会说到作用域链。

作用域链是什么？

简单来说，访问一个变量时，代码解释器会首先在当前的作用域查找，如果没找到，就去父级作用域去查找，直到找到该变量或者不存在父级作用域中，**这样的链路就是作用域链**

### 闭包的本质

闭包产生的本质就是：当前环境中存在指向父级作用域的引用

### 提出问题

按照前面的例子，是不是只有返回函数才算是产生了闭包呢？其实也不是，回到闭包的本质，我们只需要让父级作用域的引用存在即可

接下来介绍闭包的一些表现形式及应用场景



## 闭包的表现形式及应用场景

1. 返回一个函数

2. 在定时器、事件监听、ajax、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在用闭包

3. 函数参数传递

4. IIFE（立即执行函数）

   

## 闭包相关面试题

关于闭包，有一个常见的面试题：解决循环输出问题。

```js
for(var i = 1; i <= 5; i ++){
  setTimeout(() => {
    console.log(i)
  }, 0)
}
```

**执行上面代码，请问会输出什么？**

毋庸置疑，输出5个6。

**原因是什么呢？**

可以从2点去看，常见的一点分析是：由于js中单线程 eventLoop 机制，在主线程同步任务执行完后才去执行宏任务，setTimeout 为宏任务，因此循环结束后 setTimeout 中的回调才依次执行。

也可以从闭包的角度去思考：setTimeout也是一种闭包，往上找它的父级作用域链就是 window，变量 i 为 window 上的全局变量，开始执行 setTimeout 之前变量 i 已经就是 6 了，因此最后输出的连续就都是 6

**那么，我们如何解决这个问题，让他输出1，2，3，4，5呢？**

1. 使用let

es6中新增的 let 定义变量的方式，有了块级作用域，代码的作用域以块级为单位进行执行

```js
for(let i = 1; i <= 5; i++){
  setTimeout(() => {
    console.log(i);
  },0)
}
```

2. 利用 IIFE

可以利用 IIFE（立即执行函数），每次 for 循环时，把此时的变量 i 传递到定时器中，然后执行

```js
for(var i = 1;i <= 5;i++){
  ((j)=>{
    setTimeout(()=>{
      console.log(j)
    }, 0)
  })(i)
}
```

3. 定时器传入第三个参数

```js
for(var i=1;i<=5;i++){
  setTimeout((j) =>{
    console.log(j)
  }, 0, i)
}
```

注意：定时器启动时候，第三个以后的参数是作为第一个func()的参数传进去

**总结：改造量最小的，当然是用let**

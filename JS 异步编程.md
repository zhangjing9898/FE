# JS 异步编程



日常开发中都用过哪些 JS 异步编程的方式？总结起来无外乎有这几种：回调函数、事件监听、Promise、Generator、async/await，这几种 JS 的编程方式都是异步编程。



## 提出问题



1. 同步编程和异步编程的区别在哪里？
2. 回调地狱有哪些方法可以解决？



## 同步和异步的区别



### 什么是同步



同步就是在执行某段代码时，在该代码没有得到返回结果之前，其他代码暂时是无法执行的。换句话说，在此段代码执行完未返回结果之前，会阻塞之后的代码执行。



### 什么是异步



异步就是当某一代码执行异步过程调用发出后，这段代码不会立刻得到返回结果。而是在异步调用发出之后，一般通过回调函数处理这个调用之后拿到结果。异步不会影响阻塞后面的代码执行



### 为什么JS中要用异步



JavaScript 是单线程的，如果 JS 都是同步代码执行意味着什么呢？这样可能会造成阻塞，如果当前我们有一段代码需要执行时，如果使用同步的方式，那么就会阻塞后面的代码执行；而如果使用异步则不会阻塞，我们不需要等待异步代码执行的返回结果，可以继续执行该异步任务之后的代码逻辑



## 日常开发中有哪些异步



### 回调函数



早些年为了实现 JS 的异步编程，一般都采用回调函数的方式，比如比较典型的事件的回调，或者用 setTimeout/ setInterval 来实现一些异步编程的操作。



### Promise



为了解决回调地狱的问题，社区提出了 Promise 的解决方案。



但是即使使用 Promise 的链式调用，如果操作过多，其实并没有从根本上解决回调地狱的问题，只是换了一种写法，可读性虽然有所提升，但是依旧很难维护。



### Generator



Generator 函数可以看出是异步任务的容器，需要暂停的地方，都用 yield 语法来标注。

generator由 function* 定义（注意多出的 * 号）

```
function* gen() {
    let a = yield 111;
    console.log(a);
    let b = yield 222;
    console.log(b);
    let c = yield 333;
    console.log(c);
    let d = yield 444;
    console.log(d);
}
let t = gen();
t.next(1); //第一次调用next函数时，传递的参数无效，故无打印结果
t.next(2); // a输出2;
t.next(3); // b输出3; 
t.next(4); // c输出4;
t.next(5); // d输出5;
```

### async/await



ES6 之后 ES7 中又提出了新的异步解决方案：async/await，，async 是 Generator 函数的语法糖。



async/await 写起来使得 JS 的异步代码看起来像同步代码，其实异步编程发展的目标就是让异步逻辑的代码看起来像同步一样容易理解



## 总结



| 异步编程方式 | 总结                                    |
| ------------ | --------------------------------------- |
| 回调函数     | 远古时期使用的方法                      |
| Promise      | ES6新增，解决地狱回调                   |
| Generator    | 和yield配合使用，返回迭代器             |
| async/await  | async返回promise对象，await控制执行顺序 |

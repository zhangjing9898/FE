# 微前端？是什么

## 🌵 背景

我们可以先来想一下，日常工作中我们是如何进行**代码复用**的？

- 复制粘贴 Ctrl cv
- 抽离封装模块
- 打npm包



以上方法，会存在哪些问题？

- 复制粘贴

  - 增加重复的代码
  - 复用代码逻辑发生变动时需要处处修改
  - 违反 Don't Repeat Yourself 原则

- 抽离封装模块

  - 仅适用于当前项目，无法兼容多个项目要使用同一个模块

- 打npm包或库

  - 还蛮通用的...

    

> 微前端，用来将项目进行拆分和解耦



## 概念

“微前端”一词最早于在 [ThoughtWorks Technology Radar](https://www.thoughtworks.com/radar/techniques/micro-frontends) 中提出，后端的微服务概念扩展到了前端。



>  微前端的架构模式的是不断地将逻辑进行拆分，从而降低项目复杂度，提升可维护性和可复用性



## 应用场景

- 内部的平台系统
- 大型单页应用
- 对已有系统的兼容和扩展



## 核心思想



- 不限制技术栈
  - 保留选择技术栈的权利，即不同微应用可以选择不同的技术框架来实现，当然也包括制定不同的发布周期和发布流程

- 高度解耦
  - 为了避免微应用之间产生冲突，应该通过命名前缀等方式来对一些公共作用域进行隔离
  - CSS 隔离：可以采用 CSS Module 或者命名空间的方式
  - JavaScript 隔离：沙箱隔离。通过 with 关键字和 window.Proxy 对象来实现浏览器端的沙箱
- 原生优先
  - 优先使用浏览器事件进行通信，而不要使用自封装的发布订阅系统



## 架构模式



- 服务端集成微应用，比如通过 Nginx 代理转发
- 浏览器集成微应用，比如使用 Web Components 的自定义元素功能



### 服务端集成



通过反向代理，在服务端进行路由转发，即通过路径匹配将不同请求转发到对应的微应用。



### 浏览器集成



- iframe
  - 通过 iframe 的方式将不同的微应用集成到主应用中，实现成本低，但样式、兼容性方面存在一定问题

- 前端路由
  - 每个微应用暴露出渲染函数，主应用在启动时加载各个微应用的主模块，之后根据路由规则渲染相应的微应用

- Web Components
  - 基于原生的自定义元素来加载不同微应用，借助 Shadow DOM 实现隔离，改造成本比较大

代表性的框架有 [single-spa](https://github.com/single-spa/single-spa)



## 总结



1. 微前端这种架构模式来源于微服务，目的在于对项目进行拆分和隔离，提高项目的可维护性和可复用性
2. 主流的微前端实现方式大致分为两类
   1. 服务端集成 [一般通过代理转发方式]
   2. 浏览器端集成，方法较多，可以了解一下single-spa
